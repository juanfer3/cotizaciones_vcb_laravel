[["file:///home/jfvilladiego/proyectos_laravel/cotizaciones_vcb_laravel/vendor/symfony/http-kernel/EventListener/SaveSessionListener.php",{"_uri":"file:///home/jfvilladiego/proyectos_laravel/cotizaciones_vcb_laravel/vendor/symfony/http-kernel/EventListener/SaveSessionListener.php","_root":{"kind":4096,"name":"file:///home/jfvilladiego/proyectos_laravel/cotizaciones_vcb_laravel/vendor/symfony/http-kernel/EventListener/SaveSessionListener.php","location":{"uriHash":1443725041,"range":{"start":{"line":0,"character":0},"end":{"line":66,"character":0}}},"children":[{"kind":512,"name":"Symfony\\Component\\HttpKernel\\EventListener","location":{"uriHash":1443725041,"range":{"start":{"line":11,"character":0},"end":{"line":11,"character":53}}}},{"kind":1,"name":"EventSubscriberInterface","location":{"uriHash":1443725041,"range":{"start":{"line":13,"character":4},"end":{"line":13,"character":62}}},"modifiers":4096,"associated":[{"kind":1,"name":"Symfony\\Component\\EventDispatcher\\EventSubscriberInterface"}]},{"kind":1,"name":"FilterResponseEvent","location":{"uriHash":1443725041,"range":{"start":{"line":14,"character":4},"end":{"line":14,"character":58}}},"modifiers":4096,"associated":[{"kind":1,"name":"Symfony\\Component\\HttpKernel\\Event\\FilterResponseEvent"}]},{"kind":1,"name":"KernelEvents","location":{"uriHash":1443725041,"range":{"start":{"line":15,"character":4},"end":{"line":15,"character":45}}},"modifiers":4096,"associated":[{"kind":1,"name":"Symfony\\Component\\HttpKernel\\KernelEvents"}]},{"kind":1,"name":"Symfony\\Component\\HttpKernel\\EventListener\\SaveSessionListener","location":{"uriHash":1443725041,"range":{"start":{"line":44,"character":0},"end":{"line":65,"character":1}}},"children":[{"kind":32,"name":"onKernelResponse","location":{"uriHash":1443725041,"range":{"start":{"line":46,"character":4},"end":{"line":56,"character":5}}},"modifiers":1,"type":"","children":[{"kind":128,"name":"$event","location":{"uriHash":1443725041,"range":{"start":{"line":46,"character":37},"end":{"line":46,"character":63}}},"type":"Symfony\\Component\\HttpKernel\\Event\\FilterResponseEvent","scope":"onKernelResponse"}],"scope":"Symfony\\Component\\HttpKernel\\EventListener\\SaveSessionListener"},{"kind":32,"name":"getSubscribedEvents","location":{"uriHash":1443725041,"range":{"start":{"line":58,"character":4},"end":{"line":64,"character":5}}},"modifiers":33,"type":"","children":[],"scope":"Symfony\\Component\\HttpKernel\\EventListener\\SaveSessionListener"}],"associated":[{"kind":2,"name":"Symfony\\Component\\EventDispatcher\\EventSubscriberInterface"}],"doc":{"description":"Saves the session, in case it is still open, before sending the response/headers.\n\nThis ensures several things in case the developer did not save the session explicitly:\n\n* If a session save handler without locking is used, it ensures the data is available\non the next request, e.g. after a redirect. PHPs auto-save at script end via\nsession_register_shutdown is executed after fastcgi_finish_request. So in this case\nthe data could be missing the next request because it might not be saved the moment\nthe new request is processed.\n* A locking save handler (e.g. the native 'files') circumvents concurrency problems like\nthe one above. But by saving the session before long-running things in the terminate event,\nwe ensure the session is not blocked longer than needed.\n* When regenerating the session ID no locking is involved in PHPs session design. See\nhttps://bugs.php.net/bug.php?id=61470 for a discussion. So in this case, the session must\nbe saved anyway before sending the headers with the new session ID. Otherwise session\ndata could get lost again for concurrent requests with the new ID. One result could be\nthat you get logged out after just logging in.\n\nThis listener should be executed as one of the last listeners, so that previous listeners\ncan still operate on the open session. This prevents the overhead of restarting it.\nListeners after closing the session can still work with the session as usual because\nSymfonys session implementation starts the session on demand. So writing to it after\nit is saved will just restart it.","type":""},"modifiers":0}]},"_hash":1443725041}]]